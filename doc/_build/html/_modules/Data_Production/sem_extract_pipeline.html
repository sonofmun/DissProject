<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Data_Production.sem_extract_pipeline &mdash; Munson_Dissertation 0.1 documentation</title>
    
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="Munson_Dissertation 0.1 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for Data_Production.sem_extract_pipeline</h1><div class="highlight"><pre>
<span></span><span class="ch">#! /usr/bin/env python3</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s1">&#39;matt&#39;</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="n">PACKAGE_PARENT</span> <span class="o">=</span> <span class="s1">&#39;..&#39;</span>
<span class="n">SCRIPT_DIR</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span>
    <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">realpath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="n">__file__</span><span class="p">))))</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">SCRIPT_DIR</span><span class="p">,</span> <span class="n">PACKAGE_PARENT</span><span class="p">)))</span>

<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">log</span><span class="p">,</span> <span class="n">ceil</span>

<span class="kn">import</span> <span class="nn">pandas</span> <span class="kn">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">Data_Production.TK_files</span> <span class="kn">import</span> <span class="n">tk_control</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Tkinter cannot be used on this Python installation.</span><span class="se">\n</span><span class="s1">Please designate a list of files in the files variable.&#39;</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics.pairwise</span> <span class="kn">import</span> <span class="n">pairwise_distances</span>
<span class="kn">from</span> <span class="nn">glob</span> <span class="kn">import</span> <span class="n">glob</span>
<span class="c1"># from celery import group</span>
<span class="c1"># from proj.tasks import counter, svd_calc</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">combinations_with_replacement</span>
<span class="kn">from</span> <span class="nn">pickle</span> <span class="kn">import</span> <span class="n">dump</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Pool</span>
<span class="kn">from</span> <span class="nn">Data_Production.multi_tasks</span> <span class="kn">import</span> <span class="n">counter</span>
<span class="kn">import</span> <span class="nn">argparse</span>


<span class="k">class</span> <span class="nc">SemPipeline</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; This class produces matrices representing cooccurrence counts, statistical significance, and similarity data for a corpus</span>

<span class="sd">    :param win_size: context window size</span>
<span class="sd">    :type win_size: int</span>
<span class="sd">    :param lemmata: whether to use word lemmata</span>
<span class="sd">    :type lemmata: bool</span>
<span class="sd">    :param weighted: whether to use a weighted window type</span>
<span class="sd">    :type weighted: bool</span>
<span class="sd">    :param algo: the significance algorithm to use. &#39;LL&#39; and &#39;PPMI&#39; are implemented</span>
<span class="sd">    :type algo: str</span>
<span class="sd">    :param sim_algo: the similarity algorithm to use. &#39;CS&#39; is implemented</span>
<span class="sd">    :type sim_algo: str</span>
<span class="sd">    :param files: the directory in which the individual .txt files are held</span>
<span class="sd">    :type files: str</span>
<span class="sd">    :param c: the number of cores to use in self.cooc_counter (will be removed in the future)</span>
<span class="sd">    :type c: int</span>
<span class="sd">    :param occ_dict: the path and filename for the occurrence dictionary pickle</span>
<span class="sd">    :type occ_dict: str</span>
<span class="sd">    :param min_count: the minimum occurrence count below which words will not be counted</span>
<span class="sd">    :type min_count: int</span>
<span class="sd">    :param jobs: number of jobs to use during the cosine similarity calculations</span>
<span class="sd">    :type jobs: int</span>
<span class="sd">    :param stops: whether to include stop words or not (True means to include them)</span>
<span class="sd">    :type stops: bool</span>

<span class="sd">    :ivar w: the context window size</span>
<span class="sd">    :type w: int</span>
<span class="sd">    :ivar lems: whether a lemmatized or unlemmatized text will be used</span>
<span class="sd">    :type lems: bool</span>
<span class="sd">    :ivar weighted: whether a weighted or unweighted context window will be used (True == weighted)</span>
<span class="sd">    :type weighted: bool</span>
<span class="sd">    :ivar algo: which significance algorithm will be used (PPMI or LL)</span>
<span class="sd">    :type algo: str</span>
<span class="sd">    :ivar sim_algo: the similarity algorithm to be used</span>
<span class="sd">    :type sim_algo: str</span>
<span class="sd">    :ivar dir: the directory path in which the texts are located</span>
<span class="sd">    :type dir: str</span>
<span class="sd">    :ivar c: the number of cores to use during co-occurrence counting</span>
<span class="sd">    :type c: int</span>
<span class="sd">    :ivar occ_dict: the location for the dictionary representing word counts for every word</span>
<span class="sd">    :type occ_dict: str</span>
<span class="sd">    :ivar min_count: the minimum threshold of occurrences for the words to be calculated</span>
<span class="sd">    :type min_count: int</span>
<span class="sd">    :ivar jobs: the value to be used for n_jobs in the cosine similarity calculations</span>
<span class="sd">    :type jobs: int</span>
<span class="sd">    :ivar stops: a list of stop-words to ignore during the calculations</span>
<span class="sd">    :type stops: (str)</span>
<span class="sd">    :ivar ind: the indices for the rows and columns of the matrix (i.e., the words) - filled in self.cooc_counter</span>
<span class="sd">    :type ind: [str]</span>
<span class="sd">    :ivar cols: the length of self.ind - filled in self.cooc_counter</span>
<span class="sd">    :ivar cols: int</span>
<span class="sd">    :ivar coll_df: transformed into numpy.memmap and filled in self.cooc_counter</span>
<span class="sd">    :type coll_df: tuple</span>
<span class="sd">    :ivar LL_df: transformed into numpy.memmap and filled in self.LL</span>
<span class="sd">    :type LL_df: tuple</span>
<span class="sd">    :ivar PPMI_df: transformed into numpy.memmap and filled in self.PPMI</span>
<span class="sd">    :type PPMI_df: tuple</span>
<span class="sd">    :ivar CS_df: transformed into numpy.memmap and filled in self.CS</span>
<span class="sd">    :type CS_df: tuple</span>
<span class="sd">    :ivar stat_df: filled with either self.PPMI_df or self.LL_df in self.CS</span>
<span class="sd">    :type stat_df: tuple</span>
<span class="sd">    :ivar dest: the destination directory for all files - filled in self.makeFileNames</span>
<span class="sd">    :type dest: str</span>
<span class="sd">    :ivar corpus: the name of the corpus under investigation - filled in self.makeFileNames</span>
<span class="sd">    :type corpus: str</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">win_size</span><span class="o">=</span><span class="mi">350</span><span class="p">,</span> <span class="n">lemmata</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">weighted</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">algo</span><span class="o">=</span><span class="s1">&#39;PPMI&#39;</span><span class="p">,</span>
                 <span class="n">sim_algo</span><span class="o">=</span><span class="s1">&#39;cosine&#39;</span><span class="p">,</span> <span class="n">files</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">occ_dict</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">min_count</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">stops</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; This class produces matrices representing cooccurrence counts, statistical significance, and similarity data for a corpus</span>

<span class="sd">        :param win_size: context window size</span>
<span class="sd">        :type win_size: int</span>
<span class="sd">        :param lemmata: whether to use word lemmata</span>
<span class="sd">        :type lemmata: bool</span>
<span class="sd">        :param weighted: whether to use a weighted window type</span>
<span class="sd">        :type weighted: bool</span>
<span class="sd">        :param algo: the significance algorithm to use. &#39;LL&#39; and &#39;PPMI&#39; are implemented</span>
<span class="sd">        :type algo: str</span>
<span class="sd">        :param sim_algo: the similarity algorithm to use. &#39;CS&#39; is implemented</span>
<span class="sd">        :type sim_algo: str</span>
<span class="sd">        :param files: the directory in which the individual .txt files are held</span>
<span class="sd">        :type files: str</span>
<span class="sd">        :param c: the number of cores to use in self.cooc_counter (will be removed in the future)</span>
<span class="sd">        :type c: int</span>
<span class="sd">        :param occ_dict: the path and filename for the occurrence dictionary pickle</span>
<span class="sd">        :type occ_dict: str</span>
<span class="sd">        :param min_count: the minimum occurrence count below which words will not be counted</span>
<span class="sd">        :type min_count: int</span>
<span class="sd">        :param jobs: number of jobs to use during the cosine similarity calculations</span>
<span class="sd">        :type jobs: int</span>
<span class="sd">        :param stops: whether to include stop words or not (True means to include them)</span>
<span class="sd">        :type stops: bool</span>

<span class="sd">        :ivar w: the context window size</span>
<span class="sd">        :type w: int</span>
<span class="sd">        :ivar lems: whether a lemmatized or unlemmatized text will be used</span>
<span class="sd">        :type lems: bool</span>
<span class="sd">        :ivar weighted: whether a weighted or unweighted context window will be used (True == weighted)</span>
<span class="sd">        :type weighted: bool</span>
<span class="sd">        :ivar algo: which significance algorithm will be used (PPMI or LL)</span>
<span class="sd">        :type algo: str</span>
<span class="sd">        :ivar sim_algo: the similarity algorithm to be used</span>
<span class="sd">        :type sim_algo: str</span>
<span class="sd">        :ivar dir: the directory path in which the texts are located</span>
<span class="sd">        :type dir: str</span>
<span class="sd">        :ivar c: the number of cores to use during co-occurrence counting</span>
<span class="sd">        :type c: int</span>
<span class="sd">        :ivar occ_dict: the location for the dictionary representing word counts for every word</span>
<span class="sd">        :type occ_dict: str</span>
<span class="sd">        :ivar min_count: the minimum threshold of occurrences for the words to be calculated</span>
<span class="sd">        :type min_count: int</span>
<span class="sd">        :ivar jobs: the value to be used for n_jobs in the cosine similarity calculations</span>
<span class="sd">        :type jobs: int</span>
<span class="sd">        :ivar stops: a list of stop-words to ignore during the calculations</span>
<span class="sd">        :type stops: (str)</span>
<span class="sd">        :ivar ind: the indices for the rows and columns of the matrix (i.e., the words) - filled in self.cooc_counter</span>
<span class="sd">        :type ind: [str]</span>
<span class="sd">        :ivar cols: the length of self.ind - filled in self.cooc_counter</span>
<span class="sd">        :ivar cols: int</span>
<span class="sd">        :ivar coll_df: transformed into numpy.memmap and filled in self.cooc_counter</span>
<span class="sd">        :type coll_df: tuple</span>
<span class="sd">        :ivar LL_df: transformed into numpy.memmap and filled in self.LL</span>
<span class="sd">        :type LL_df: tuple</span>
<span class="sd">        :ivar PPMI_df: transformed into numpy.memmap and filled in self.PPMI</span>
<span class="sd">        :type PPMI_df: tuple</span>
<span class="sd">        :ivar CS_df: transformed into numpy.memmap and filled in self.CS</span>
<span class="sd">        :type CS_df: tuple</span>
<span class="sd">        :ivar stat_df: filled with either self.PPMI_df or self.LL_df in self.CS</span>
<span class="sd">        :type stat_df: tuple</span>
<span class="sd">        :ivar dest: the destination directory for all files - filled in self.makeFileNames</span>
<span class="sd">        :type dest: str</span>
<span class="sd">        :ivar corpus: the name of the corpus under investigation - filled in self.makeFileNames</span>
<span class="sd">        :type corpus: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">w</span> <span class="o">=</span> <span class="n">win_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lems</span> <span class="o">=</span> <span class="n">lemmata</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weighted</span> <span class="o">=</span> <span class="n">weighted</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">algo</span> <span class="o">=</span> <span class="n">algo</span>
        <span class="k">if</span> <span class="n">sim_algo</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;cityblock&#39;</span><span class="p">,</span> <span class="s1">&#39;cosine&#39;</span><span class="p">,</span> <span class="s1">&#39;euclidean&#39;</span><span class="p">,</span> <span class="s1">&#39;l1&#39;</span><span class="p">,</span> <span class="s1">&#39;l2&#39;</span><span class="p">,</span>
                        <span class="s1">&#39;manhattan&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sim_algo</span> <span class="o">=</span> <span class="n">sim_algo</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span>
                <span class="s2">&quot;The only accepted values for &#39;sim_algo&#39; are &#39;cityblock&#39;, &#39;cosine&#39;, &#39;euclidean&#39;, &#39;l1&#39;, &#39;l2&#39;, or &#39;manhattan&#39;&quot;</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Setting &#39;sim_algo&#39; to &#39;cosine&#39;&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sim_algo</span> <span class="o">=</span> <span class="s1">&#39;cosine&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">algo</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;PPMI&#39;</span><span class="p">,</span> <span class="s1">&#39;LL&#39;</span><span class="p">,</span> <span class="s1">&#39;both&#39;</span><span class="p">]:</span>
            <span class="k">print</span><span class="p">(</span>
                <span class="s1">&#39;The only accepted values for &quot;algo&quot; are &quot;PPMI&quot;, &quot;LL&quot;, or &quot;both&quot;.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dir</span> <span class="o">=</span> <span class="n">files</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">c</span>
        <span class="k">if</span> <span class="n">occ_dict</span> <span class="o">==</span> <span class="s1">&#39;None&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">occ_dict</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">occ_dict</span> <span class="o">=</span> <span class="n">occ_dict</span>
        <span class="k">if</span> <span class="n">min_count</span> <span class="o">==</span> <span class="s1">&#39;None&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">min_count</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">min_count</span> <span class="o">=</span> <span class="n">min_count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jobs</span> <span class="o">=</span> <span class="n">jobs</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">stops</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stops</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;μή&#39;</span><span class="p">,</span> <span class="s1">&#39;ἑαυτοῦ&#39;</span><span class="p">,</span> <span class="s1">&#39;ἄν&#39;</span><span class="p">,</span> <span class="s1">&#39;ἀλλ’&#39;</span><span class="p">,</span> <span class="s1">&#39;ἀλλά&#39;</span><span class="p">,</span> <span class="s1">&#39;ἄλλος&#39;</span><span class="p">,</span> <span class="s1">&#39;ἀπό&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;ἄρα&#39;</span><span class="p">,</span> <span class="s1">&#39;αὐτός&#39;</span><span class="p">,</span> <span class="s1">&#39;δ’&#39;</span><span class="p">,</span> <span class="s1">&#39;δέ&#39;</span><span class="p">,</span> <span class="s1">&#39;δή&#39;</span><span class="p">,</span> <span class="s1">&#39;διά&#39;</span><span class="p">,</span> <span class="s1">&#39;δαί&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;δαίς&#39;</span><span class="p">,</span> <span class="s1">&#39;ἔτι&#39;</span><span class="p">,</span> <span class="s1">&#39;ἐγώ&#39;</span><span class="p">,</span> <span class="s1">&#39;ἐκ&#39;</span><span class="p">,</span> <span class="s1">&#39;ἐμός&#39;</span><span class="p">,</span> <span class="s1">&#39;ἐν&#39;</span><span class="p">,</span> <span class="s1">&#39;ἐπί&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;εἰ&#39;</span><span class="p">,</span> <span class="s1">&#39;εἰμί&#39;</span><span class="p">,</span> <span class="s1">&#39;εἴμι&#39;</span><span class="p">,</span> <span class="s1">&#39;εἰς&#39;</span><span class="p">,</span> <span class="s1">&#39;γάρ&#39;</span><span class="p">,</span> <span class="s1">&#39;γε&#39;</span><span class="p">,</span> <span class="s1">&#39;γα^&#39;</span><span class="p">,</span> <span class="s1">&#39;ἡ&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;ἤ&#39;</span><span class="p">,</span> <span class="s1">&#39;καί&#39;</span><span class="p">,</span> <span class="s1">&#39;κατά&#39;</span><span class="p">,</span> <span class="s1">&#39;μέν&#39;</span><span class="p">,</span> <span class="s1">&#39;μετά&#39;</span><span class="p">,</span> <span class="s1">&#39;μή&#39;</span><span class="p">,</span> <span class="s1">&#39;ὁ&#39;</span><span class="p">,</span> <span class="s1">&#39;ὅδε&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;ὅς&#39;</span><span class="p">,</span> <span class="s1">&#39;ὅστις&#39;</span><span class="p">,</span> <span class="s1">&#39;ὅτι&#39;</span><span class="p">,</span> <span class="s1">&#39;οὕτως&#39;</span><span class="p">,</span> <span class="s1">&#39;οὗτος&#39;</span><span class="p">,</span> <span class="s1">&#39;οὔτε&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;οὖν&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;οὐδείς&#39;</span><span class="p">,</span> <span class="s1">&#39;οἱ&#39;</span><span class="p">,</span> <span class="s1">&#39;οὐ&#39;</span><span class="p">,</span> <span class="s1">&#39;οὐδέ&#39;</span><span class="p">,</span> <span class="s1">&#39;οὐκ&#39;</span><span class="p">,</span> <span class="s1">&#39;περί&#39;</span><span class="p">,</span> <span class="s1">&#39;πρός&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;σύ&#39;</span><span class="p">,</span> <span class="s1">&#39;σύν&#39;</span><span class="p">,</span> <span class="s1">&#39;τά&#39;</span><span class="p">,</span> <span class="s1">&#39;τε&#39;</span><span class="p">,</span> <span class="s1">&#39;τήν&#39;</span><span class="p">,</span> <span class="s1">&#39;τῆς&#39;</span><span class="p">,</span> <span class="s1">&#39;τῇ&#39;</span><span class="p">,</span> <span class="s1">&#39;τι&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;τί&#39;</span><span class="p">,</span> <span class="s1">&#39;τις&#39;</span><span class="p">,</span> <span class="s1">&#39;τίς&#39;</span><span class="p">,</span> <span class="s1">&#39;τό&#39;</span><span class="p">,</span> <span class="s1">&#39;τοί&#39;</span><span class="p">,</span> <span class="s1">&#39;τοιοῦτος&#39;</span><span class="p">,</span> <span class="s1">&#39;τόν&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;τούς&#39;</span><span class="p">,</span> <span class="s1">&#39;τοῦ&#39;</span><span class="p">,</span> <span class="s1">&#39;τῶν&#39;</span><span class="p">,</span> <span class="s1">&#39;τῷ&#39;</span><span class="p">,</span> <span class="s1">&#39;ὑμός&#39;</span><span class="p">,</span> <span class="s1">&#39;ὑπέρ&#39;</span><span class="p">,</span> <span class="s1">&#39;ὑπό&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;ὡς&#39;</span><span class="p">,</span> <span class="s1">&#39;ὦ&#39;</span><span class="p">,</span> <span class="s1">&#39;ὥστε&#39;</span><span class="p">,</span> <span class="s1">&#39;ἐάν&#39;</span><span class="p">,</span> <span class="s1">&#39;παρά&#39;</span><span class="p">,</span> <span class="s1">&#39;σός&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stops</span> <span class="o">=</span> <span class="p">()</span>

        <span class="c1"># the following ivars are filled later in the class</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ind</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coll_df</span> <span class="o">=</span> <span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">LL_df</span> <span class="o">=</span> <span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">PPMI_df</span> <span class="o">=</span> <span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">CS_df</span> <span class="o">=</span> <span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stat_df</span> <span class="o">=</span> <span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dest</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

    <span class="k">def</span> <span class="nf">file_chooser</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Uses tkinter.filedialog, as implemented in the tk_control class to fill self.dir if files=None</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dir</span> <span class="o">=</span> <span class="n">tk_control</span><span class="p">(</span><span class="s2">&quot;askdirectory(title=&#39;In which directory are the XML file(s) would you like to analyze?&#39;)&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">word_extract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">stops</span><span class="o">=</span><span class="p">()):</span>
        <span class="sd">&quot;&quot;&quot; Extracts a list of words from self.t</span>

<span class="sd">        :return: list of words</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">words</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">text</span><span class="p">:</span>
            <span class="n">word</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="s1">r&#39;\1&#39;</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">word</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span> <span class="ow">and</span> <span class="n">word</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">stops</span><span class="p">:</span>
                <span class="n">words</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">words</span>

    <span class="k">def</span> <span class="nf">cooc_counter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Counts the number of times each word co-occurs with each other word</span>

<span class="sd">        :ivar ind: the words that represent the ordered indices of all matrices produced in later calculation</span>
<span class="sd">        :type ind: [int]</span>
<span class="sd">        :ivar coll_df: self.coll_df</span>
<span class="sd">        :type coll_df: numpy.memmap</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cooc_dest</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dest</span><span class="p">,</span>
                                 <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;COOC&#39;</span><span class="p">,</span>
                                           <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">),</span>
                                           <span class="s1">&#39;lems={0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lems</span><span class="p">),</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">,</span>
                                           <span class="s1">&#39;min_occ={0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                               <span class="bp">self</span><span class="o">.</span><span class="n">min_count</span><span class="p">),</span>
                                           <span class="s1">&#39;no_stops={0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                               <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stops</span><span class="p">)),</span>
                                           <span class="s1">&#39;weighted={}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                               <span class="bp">self</span><span class="o">.</span><span class="n">weighted</span><span class="p">)])</span> <span class="o">+</span> <span class="s1">&#39;.dat&#39;</span><span class="p">)</span>
        <span class="c1"># Check to see if a cooccurrence file already exists, if so, exit the method</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">cooc_dest</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ind</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_pickle</span><span class="p">(</span>
                <span class="s1">&#39;{0}/{1}_IndexList_w={2}_lems={3}_min_occs={4}_no_stops={5}.pickle&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dest</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lems</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_count</span><span class="p">,</span>
                    <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stops</span><span class="p">)))</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">occs</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_pickle</span><span class="p">(</span>
                    <span class="s1">&#39;{0}/{1}_ColumnList_w={2}_lems={3}_min_occs={4}_no_stops={5}.pickle&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">dest</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lems</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">min_count</span><span class="p">,</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stops</span><span class="p">)))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">occs</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ind</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coll_df</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span><span class="n">cooc_dest</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span>
                                     <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ind</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">))</span>
            <span class="k">return</span>

        <span class="c1"># Initialize local variables</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lems</span><span class="p">:</span>
            <span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">r&#39;.+?lem=&quot;([^&quot;]*).*&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">r&#39;.+?&gt;([^&lt;]*).*&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">occ_dict</span><span class="p">:</span>
            <span class="n">occs</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_pickle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">occ_dict</span><span class="p">)</span>
            <span class="n">min_lems</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">occs</span> <span class="k">if</span> <span class="n">occs</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_count</span><span class="p">])</span>
            <span class="k">del</span> <span class="n">occs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">min_lems</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="c1"># Compute co-occurrence counts for each file in self.dir</span>
        <span class="k">for</span> <span class="nb">file</span> <span class="ow">in</span> <span class="n">glob</span><span class="p">(</span><span class="s1">&#39;{0}/*.txt&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dir</span><span class="p">)):</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="nb">file</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">words</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">word_extract</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">),</span> <span class="n">pattern</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stops</span><span class="p">)</span>
            <span class="n">step</span> <span class="o">=</span> <span class="n">ceil</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">)</span>
            <span class="n">steps</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">):</span>
                <span class="n">steps</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">step</span> <span class="o">*</span> <span class="n">i</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">step</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">))))</span>
            <span class="sd">&#39;&#39;&#39;self.res = group(</span>
<span class="sd">                counter.s(self.weighted, self.w, words, limits) for limits in</span>
<span class="sd">                steps)().get()</span>
<span class="sd">            &#39;&#39;&#39;</span>
            <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">with</span> <span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">limits</span> <span class="ow">in</span> <span class="n">steps</span><span class="p">:</span>
                    <span class="n">results</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weighted</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="n">words</span><span class="p">,</span> <span class="n">limits</span><span class="p">))</span>
                    <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>
            <span class="c1">#since the counter task returns Counter objects, the update method</span>
            <span class="c1">#below adds instead of replacing the values</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">res</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">min_lems</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">counts</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                            <span class="n">counts</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">counts</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="c1"># Fill the ivars that come from the co-occurrence counts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ind</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">counts</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ind</span><span class="p">)</span>

        <span class="c1"># Write the counts dictionary to a numpy.memmap file</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Now writing cooccurrence file at {0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">.</span><span class="n">isoformat</span><span class="p">()))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coll_df</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span><span class="n">cooc_dest</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w+&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ind</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">counts</span><span class="p">[</span><span class="n">w</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ind</span><span class="p">,</span>
                          <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coll_df</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">values</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">5000</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s1">&#39;{0}</span><span class="si">% d</span><span class="s1">one&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">((</span><span class="n">i</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)))</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">coll_df</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">coll_df</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span><span class="n">cooc_dest</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r+&#39;</span><span class="p">,</span>
                                         <span class="n">shape</span><span class="o">=</span><span class="p">(</span>
                                             <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">))</span>

        <span class="c1"># Re-open self.coll_df as read-only</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">coll_df</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coll_df</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span><span class="n">cooc_dest</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">))</span>

        <span class="c1"># Save the index list and the column list</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;{0}/{1}_IndexList_w={2}_lems={3}_min_occs={4}_no_stops={5}.pickle&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dest</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lems</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_count</span><span class="p">,</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stops</span><span class="p">)),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ind</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;{0}/{1}_ColumnList_w={2}_lems={3}_min_occs={4}_no_stops={5}.pickle&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dest</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lems</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_count</span><span class="p">,</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stops</span><span class="p">)),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ind</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">log_L</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Calculates the values for the individual elements of the Log-likelihood equation using the</span>
<span class="sd">        binomial distribution function L(k,n,x) = (x**k)*(1-x)**(n-k).</span>

<span class="sd">        :param k:</span>
<span class="sd">        :type k: pandas.Series</span>
<span class="sd">        :param n:</span>
<span class="sd">        :type n: numpy.ndarray</span>
<span class="sd">        :param x:</span>
<span class="sd">        :type x: numpy.ndarray</span>
<span class="sd">        :return: Log-likelihood values</span>
<span class="sd">        :rtype: numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">k</span><span class="p">)</span>
                      <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x</span><span class="p">),</span> <span class="n">n</span> <span class="o">-</span> <span class="n">k</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">log_space_L</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Calculates the values for the individual elements of the Log-likelihood equation using the</span>
<span class="sd">        binomial distribution function L(k,n,x) = (x**k)*(1-x)**(n-k).</span>
<span class="sd">        Moves the calculations to log-space to deal with floats that are too small for float64.</span>

<span class="sd">        :param k:</span>
<span class="sd">        :type k: numpy.ndarray</span>
<span class="sd">        :param n:</span>
<span class="sd">        :type n: float</span>
<span class="sd">        :param x:</span>
<span class="sd">        :type x: numpy.ndarray</span>
<span class="sd">        :return: Log-likelihood values</span>
<span class="sd">        :rtype: numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">log_like</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">C2</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Guides the process of Log-likelihood calculations for a single row</span>

<span class="sd">        :param row: the index of the row in the table to be calculated</span>
<span class="sd">        :type row: int</span>
<span class="sd">        :param C2: number of co-occurrences for each row of the table</span>
<span class="sd">        :type C2: numpy.ndarray</span>
<span class="sd">        :param P: ratio of co-occurrences per row to total co-occurrences in the table</span>
<span class="sd">        :type P: numpy.ndarray</span>
<span class="sd">        :param N: total number of co-occurrences in the table</span>
<span class="sd">        :type N: float</span>
<span class="sd">        :return: Log-likelihood values for a single row in the table</span>
<span class="sd">        :rtype: numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">C12</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coll_df</span><span class="p">[</span><span class="n">row</span><span class="p">]</span>
        <span class="n">C1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">C12</span><span class="p">)</span>
        <span class="c1"># P1 is ratio of single co-occurrence values to the total co-occurrences for that row</span>
        <span class="n">P1</span> <span class="o">=</span> <span class="n">C12</span> <span class="o">/</span> <span class="n">C1</span>
        <span class="c1"># P2 ratio of total co-occurrences for a word minus the co-occurrences</span>
        <span class="c1"># with the word in question to the total number of co-occurrences in</span>
        <span class="c1"># the table minus the total co-occurrences for the row.</span>
        <span class="n">P2</span> <span class="o">=</span> <span class="p">(</span><span class="n">C2</span> <span class="o">-</span> <span class="n">C12</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="n">C1</span><span class="p">)</span>

        <span class="n">LL1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_space_L</span><span class="p">(</span><span class="n">C12</span><span class="p">,</span> <span class="n">C1</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span>
        <span class="n">LL2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_space_L</span><span class="p">(</span><span class="n">C2</span> <span class="o">-</span> <span class="n">C12</span><span class="p">,</span> <span class="n">N</span> <span class="o">-</span> <span class="n">C1</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span>
        <span class="n">LL3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_L</span><span class="p">(</span><span class="n">C12</span><span class="p">,</span> <span class="n">C1</span><span class="p">,</span> <span class="n">P1</span><span class="p">)</span>

        <span class="c1"># The following finds all inf and -inf values in LL3 by moving calculations into log space.</span>

        <span class="n">LL3_inf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">LL3</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">LL3_inf</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">LL3_inf</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">LL3</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">P1</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span> <span class="o">*</span> <span class="n">C12</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span>
                        <span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">P1</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">C1</span> <span class="o">-</span> <span class="n">C12</span><span class="p">[</span><span class="n">ind</span><span class="p">]))</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="n">LL3</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">LL4</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_space_L</span><span class="p">(</span><span class="n">C2</span> <span class="o">-</span> <span class="n">C12</span><span class="p">,</span> <span class="n">N</span> <span class="o">-</span> <span class="n">C1</span><span class="p">,</span> <span class="n">P2</span><span class="p">)</span>

        <span class="c1"># The following finds all inf and -inf values in LL4 by moving calculations into log space.</span>

        <span class="n">LL4_inf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">LL4</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">LL4_inf</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">LL4_inf</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">LL4</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_L</span><span class="p">((</span><span class="n">C2</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">-</span> <span class="n">C12</span><span class="p">[</span><span class="n">ind</span><span class="p">]),</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="n">C1</span><span class="p">),</span>
                                          <span class="n">P2</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="n">LL4</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">LL1</span> <span class="o">+</span> <span class="n">LL2</span> <span class="o">-</span> <span class="n">LL3</span> <span class="o">-</span> <span class="n">LL4</span><span class="p">)</span>
        <span class="n">a</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="bp">False</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">a</span>

    <span class="k">def</span> <span class="nf">LL</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Guides the Log-likelihood calculations for the whole matrix</span>

<span class="sd">        :ivar LL_df: matrix of log-likelihood values</span>
<span class="sd">        :type LL_df: numpy.memmap</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dest_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dest</span><span class="p">,</span>
                                 <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;LL&#39;</span><span class="p">,</span>
                                           <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">),</span>
                                           <span class="s1">&#39;lems={0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lems</span><span class="p">),</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">,</span>
                                           <span class="s1">&#39;min_occ={0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                               <span class="bp">self</span><span class="o">.</span><span class="n">min_count</span><span class="p">),</span>
                                           <span class="s1">&#39;no_stops={0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                               <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stops</span><span class="p">)),</span>
                                           <span class="s1">&#39;weighted={}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                               <span class="bp">self</span><span class="o">.</span><span class="n">weighted</span><span class="p">)])</span> <span class="o">+</span> <span class="s1">&#39;.dat&#39;</span><span class="p">)</span>

        <span class="c1"># If a log-likelihood file exists already for these parameters, exit the method</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">dest_file</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">LL_df</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span><span class="n">dest_file</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span>
                                   <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">))</span>
            <span class="k">return</span>

        <span class="c1"># Initialize local variables</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coll_df</span><span class="p">)</span>
        <span class="n">c2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coll_df</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">/</span> <span class="n">n</span>

        <span class="c1"># Fill self.LL_df with log-likelihood values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">LL_df</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span><span class="n">dest_file</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w+&#39;</span><span class="p">,</span>
                               <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ind</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">LL_df</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_like</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">5000</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s1">&#39;{0}</span><span class="si">% d</span><span class="s1">one&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">((</span><span class="n">i</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)))</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">LL_df</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">LL_df</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span><span class="n">dest_file</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r+&#39;</span><span class="p">,</span>
                                       <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">))</span>

        <span class="c1"># Change all numpy.nan and numpy.inf values to 0</span>
        <span class="c1"># This is necessary for later calculations that will raise errors for non-finite values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">LL_df</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">LL_df</span><span class="p">)</span> <span class="o">==</span> <span class="bp">False</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Dump memory and reload self.LL_df as read-only</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">LL_df</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">LL_df</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span><span class="n">dest_file</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">PMI_calc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Calculates PPMI values for one table row</span>

<span class="sd">        :param row: index for the word&#39;s row in the table</span>
<span class="sd">        :type row: int</span>
<span class="sd">        :param P2: ratio of co-occurrences per row to total co-occurrences in the table</span>
<span class="sd">        :type P2: Numpy ndarray</span>
<span class="sd">        :param N: total co-occurrences in the table</span>
<span class="sd">        :type N: float</span>
<span class="sd">        :return: PPMI values for a row in the table</span>
<span class="sd">        :rtype: Numpy ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">C12</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coll_df</span><span class="p">[</span><span class="n">row</span><span class="p">]</span>
        <span class="c1"># C1 is the total co-occurrences in the row</span>
        <span class="n">C1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">C12</span><span class="p">)</span>
        <span class="c1"># P1 is the probability that the word co-occurs</span>
        <span class="n">P1</span> <span class="o">=</span> <span class="n">C1</span> <span class="o">/</span> <span class="n">N</span>
        <span class="c1"># P12 is a vector of the probabilities that the word occurs with any other word</span>
        <span class="n">P12</span> <span class="o">=</span> <span class="n">C12</span> <span class="o">/</span> <span class="n">N</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">P12</span><span class="p">,</span> <span class="n">P1</span> <span class="o">*</span> <span class="n">P2</span><span class="p">))</span>
        <span class="n">a</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="bp">False</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">a</span><span class="p">[</span><span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">a</span>

    <span class="k">def</span> <span class="nf">PPMI</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Guides the PPMI calculation process for the whole table</span>

<span class="sd">        :ivar PPMI_df: matrix of PPMI values</span>
<span class="sd">        :type PPMI_df: numpy.memmap</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dest_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dest</span><span class="p">,</span>
                                 <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;PPMI&#39;</span><span class="p">,</span>
                                           <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">),</span>
                                           <span class="s1">&#39;lems={0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lems</span><span class="p">),</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">,</span>
                                           <span class="s1">&#39;min_occ={0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                               <span class="bp">self</span><span class="o">.</span><span class="n">min_count</span><span class="p">),</span>
                                           <span class="s1">&#39;no_stops={0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                               <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stops</span><span class="p">)),</span>
                                           <span class="s1">&#39;weighted={}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                               <span class="bp">self</span><span class="o">.</span><span class="n">weighted</span><span class="p">)])</span> <span class="o">+</span> <span class="s1">&#39;.dat&#39;</span><span class="p">)</span>

        <span class="c1"># If a PPMI file already exists, exit the method</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">dest_file</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">PPMI_df</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span><span class="n">dest_file</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span>
                                     <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">))</span>
            <span class="k">return</span>

        <span class="c1"># Initialize local variables</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coll_df</span><span class="p">)</span>
        <span class="c1">#values for C2</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coll_df</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span>

        <span class="c1"># Fill self.PPMI_df with values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">PPMI_df</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span><span class="n">dest_file</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w+&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ind</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">PPMI_df</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">PMI_calc</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">5000</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s1">&#39;{0}</span><span class="si">% d</span><span class="s1">one&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">((</span><span class="n">i</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)))</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">PPMI_df</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">PPMI_df</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span><span class="n">dest_file</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r+&#39;</span><span class="p">,</span>
                                         <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">))</span>

        <span class="c1"># Change all numpy.nan and numpy.inf values to 0</span>
        <span class="c1"># This is necessary for later calculations that will raise errors for non-finite values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">PPMI_df</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">PPMI_df</span><span class="p">)</span> <span class="o">==</span> <span class="bp">False</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Dump memory and reload self.PPMI_df as read-only</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">PPMI_df</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">PPMI_df</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span><span class="n">dest_file</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span>
                                 <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">CS</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">algorithm</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Calculates the cosine similarity of every matrix row with every other row</span>

<span class="sd">        :param algorithm: which algorithm (PPMI or LL) is being tested</span>
<span class="sd">        :type algorithm: str</span>
<span class="sd">        :param e: SVD exponent</span>
<span class="sd">        :type e: float</span>
<span class="sd">        :ivar CS_df: matrix of cosine similarity values</span>
<span class="sd">        :type CS_df: numpy.memmap</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Starting {} calculations for {} for &#39;</span>
              <span class="s1">&#39;w={}, lem={}, weighted={} at {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sim_algo</span><span class="p">,</span>
                                                       <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">,</span>
                                                       <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">),</span>
                                                       <span class="bp">self</span><span class="o">.</span><span class="n">lems</span><span class="p">,</span>
                                                       <span class="bp">self</span><span class="o">.</span><span class="n">weighted</span><span class="p">,</span>
                                                       <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">.</span><span class="n">isoformat</span><span class="p">()))</span>
        <span class="n">dest_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dest</span><span class="p">,</span>
                                 <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">algorithm</span><span class="p">,</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">sim_algo</span><span class="p">,</span>
                                           <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">),</span>
                                           <span class="s1">&#39;lems={0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lems</span><span class="p">),</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">,</span>
                                           <span class="s1">&#39;min_occ={0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                               <span class="bp">self</span><span class="o">.</span><span class="n">min_count</span><span class="p">),</span>
                                           <span class="s1">&#39;no_stops={0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                               <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stops</span><span class="p">)),</span>
                                           <span class="s1">&#39;weighted={}.dat&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                               <span class="bp">self</span><span class="o">.</span><span class="n">weighted</span><span class="p">)]))</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">dest_file</span><span class="p">):</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">algorithm</span> <span class="o">==</span> <span class="s1">&#39;PPMI&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stat_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">PPMI_df</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stat_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dest</span><span class="p">,</span>
                                          <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                                              <span class="p">[</span><span class="s1">&#39;PPMI&#39;</span><span class="p">,</span>
                                               <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">),</span>
                                               <span class="s1">&#39;lems={0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lems</span><span class="p">),</span>
                                               <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">,</span>
                                               <span class="s1">&#39;min_occ={0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_count</span><span class="p">),</span>
                                               <span class="s1">&#39;no_stops={0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stops</span><span class="p">)),</span>
                                               <span class="s1">&#39;weighted={}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weighted</span><span class="p">)]</span>
                                          <span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.dat&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">algorithm</span> <span class="o">==</span> <span class="s1">&#39;LL&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stat_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LL_df</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stat_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dest</span><span class="p">,</span>
                                          <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                                              <span class="p">[</span><span class="s1">&#39;LL&#39;</span><span class="p">,</span>
                                               <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">),</span>
                                               <span class="s1">&#39;lems={0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lems</span><span class="p">),</span>
                                               <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">,</span>
                                               <span class="s1">&#39;min_occ={0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_count</span><span class="p">),</span>
                                               <span class="s1">&#39;no_stops={0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stops</span><span class="p">)),</span>
                                               <span class="s1">&#39;weighted={}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weighted</span><span class="p">)]</span>
                                          <span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.dat&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">CS_df</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span><span class="n">dest_file</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w+&#39;</span><span class="p">,</span>
                               <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">))</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        if self.sim_algo == &#39;cosine&#39;:</span>
<span class="sd">            self.CS_df[:] = 1 - pairwise_distances(self.stat_df,</span>
<span class="sd">                                                   metric=self.sim_algo,</span>
<span class="sd">                                                   n_jobs=self.jobs)</span>
<span class="sd">        else:</span>
<span class="sd">            self.CS_df[:] = pairwise_distances(self.stat_df,</span>
<span class="sd">                                               metric=self.sim_algo,</span>
<span class="sd">                                               n_jobs=self.jobs)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cs_loop</span><span class="p">(</span><span class="n">dest_file</span><span class="p">)</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">CS_df</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">CS_df</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span><span class="n">dest_file</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">))</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Finished with {} calculations for {} for &#39;</span>
              <span class="s1">&#39;w={}, lem={}, weighted={} at {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sim_algo</span><span class="p">,</span>
                                                       <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">,</span>
                                                       <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">),</span>
                                                       <span class="bp">self</span><span class="o">.</span><span class="n">lems</span><span class="p">,</span>
                                                       <span class="bp">self</span><span class="o">.</span><span class="n">weighted</span><span class="p">,</span>
                                                       <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">.</span><span class="n">isoformat</span><span class="p">()))</span>

    <span class="k">def</span> <span class="nf">cs_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dest_file</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Divides self.stat_df into chunks more easily handled in memory</span>
<span class="sd">        (the number of rows use at a time is determined in the step variable)</span>
<span class="sd">        and then loops through all chunk combinations</span>

<span class="sd">        :param dest_file: the file name to which to save the CS data</span>
<span class="sd">        :type dest_file: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">step</span> <span class="o">=</span> <span class="mi">5000</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span>
        <span class="n">steps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">step</span>
        <span class="k">while</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">ind</span><span class="p">:</span>
            <span class="n">steps</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">step</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
            <span class="n">x</span> <span class="o">+=</span> <span class="n">step</span>
        <span class="n">steps</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">steps</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">ind</span><span class="p">))</span>
        <span class="n">last_ind</span> <span class="o">=</span> <span class="n">steps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span> <span class="ow">in</span> <span class="n">combinations_with_replacement</span><span class="p">(</span><span class="n">steps</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">part1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stat_df</span><span class="p">[</span><span class="n">i1</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">i1</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">part2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stat_df</span><span class="p">[</span><span class="n">i2</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">i2</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">CS_df</span><span class="p">[</span><span class="n">i1</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">i1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">i2</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">i2</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span> <span class="n">pairwise_distances</span><span class="p">(</span><span class="n">part1</span><span class="p">,</span> <span class="n">part2</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;cosine&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">CS_df</span><span class="p">[</span><span class="n">i2</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">i2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">i1</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">i1</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CS_df</span><span class="p">[</span><span class="n">i1</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">i1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">i2</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">i2</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">T</span>
            <span class="k">if</span> <span class="n">last_ind</span> <span class="o">!=</span> <span class="n">i1</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s1">&#39;{0}</span><span class="si">% d</span><span class="s1">one&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">((</span><span class="n">i1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">ind</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span><span class="p">))</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">CS_df</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">CS_df</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span><span class="n">dest_file</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r+&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">ind</span><span class="p">))</span>
            <span class="n">last_ind</span> <span class="o">=</span> <span class="n">i1</span>
        <span class="sd">&#39;&#39;&#39;for df_ind in steps:</span>
<span class="sd">            part1 = self.stat_df[df_ind:min(df_ind + step, ind)]</span>
<span class="sd">            for df_ind2 in steps2:</span>
<span class="sd">                part2 = self.stat_df[df_ind2:min(df_ind2 + step, ind)]</span>
<span class="sd">                self.CS_df[df_ind:min(df_ind + step, ind), df_ind2:min(df_ind2 + step, ind)] = 1- pairwise_distances(part1, part2, metric=&#39;cosine&#39;)</span>
<span class="sd">            print(&#39;{0}% done&#39;.format((df_ind / self.cols * 100)))</span>
<span class="sd">            del self.CS_df</span>
<span class="sd">            self.CS_df = np.memmap(dest_file, dtype=&#39;float&#39;, mode=&#39;r+&#39;, shape=(ind, ind))</span>
<span class="sd">        &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="nf">stat_eval</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Guides the statistical significance calculations required by the parameters given in self.__init__</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Starting </span><span class="si">%s</span><span class="s1"> calculations for </span><span class="si">%s</span><span class="s1"> for &#39;</span>
              <span class="s1">&#39;w=</span><span class="si">%s</span><span class="s1">, lem=</span><span class="si">%s</span><span class="s1">, weighted=</span><span class="si">%s</span><span class="s1"> at </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span>
              <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">algo</span><span class="p">,</span>
               <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">,</span>
               <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">),</span>
               <span class="bp">self</span><span class="o">.</span><span class="n">lems</span><span class="p">,</span>
               <span class="bp">self</span><span class="o">.</span><span class="n">weighted</span><span class="p">,</span>
               <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">.</span><span class="n">isoformat</span><span class="p">()))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">algo</span> <span class="o">==</span> <span class="s1">&#39;both&#39;</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Starting PPMI at {0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s1">&#39;date&#39;</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">PPMI</span><span class="p">()</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Starting LL at {0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s1">&#39;date&#39;</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">LL</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">algo</span> <span class="o">==</span> <span class="s1">&#39;PPMI&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">PPMI</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">algo</span> <span class="o">==</span> <span class="s1">&#39;LL&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">LL</span><span class="p">()</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">coll_df</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Finished with </span><span class="si">%s</span><span class="s1"> calculations for </span><span class="si">%s</span><span class="s1"> for &#39;</span>
              <span class="s1">&#39;w=</span><span class="si">%s</span><span class="s1">, lem=</span><span class="si">%s</span><span class="s1">, weighted=</span><span class="si">%s</span><span class="s1"> at </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span>
              <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">algo</span><span class="p">,</span>
               <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">,</span>
               <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">),</span>
               <span class="bp">self</span><span class="o">.</span><span class="n">lems</span><span class="p">,</span>
               <span class="bp">self</span><span class="o">.</span><span class="n">weighted</span><span class="p">,</span>
               <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">.</span><span class="n">isoformat</span><span class="p">()))</span>

    <span class="k">def</span> <span class="nf">makeFileNames</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Constructs the name of the destination directory and creates the directory if needed</span>

<span class="sd">        :ivar dest: the directory path into which the results will be saved</span>
<span class="sd">        :type dest: str</span>
<span class="sd">        :ivar corpus: the name of the corpus being analyzed</span>
<span class="sd">        :type corpus: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dest</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dir</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dest</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">corpus</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dir</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">runPipeline</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Guides the whole Pipeline process using the params given in self.__init__</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">dir</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">file_chooser</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">makeFileNames</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Started analyzing </span><span class="si">%s</span><span class="s1"> at </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span>
              <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corpus</span><span class="p">,</span>
               <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">.</span><span class="n">isoformat</span><span class="p">()))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cooc_counter</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stat_eval</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">algo</span> <span class="o">==</span> <span class="s1">&#39;both&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">CS</span><span class="p">(</span><span class="s1">&#39;PPMI&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">CS</span><span class="p">(</span><span class="s1">&#39;LL&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">algo</span> <span class="o">==</span> <span class="s1">&#39;PPMI&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">CS</span><span class="p">(</span><span class="s1">&#39;PPMI&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">algo</span> <span class="o">==</span> <span class="s1">&#39;LL&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">CS</span><span class="p">(</span><span class="s1">&#39;LL&#39;</span><span class="p">)</span>

        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Finished at </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">.</span><span class="n">isoformat</span><span class="p">()))</span>


<div class="viewcode-block" id="ParamTester"><a class="viewcode-back" href="../../chapter1.html#Data_Production.sem_extract_pipeline.ParamTester">[docs]</a><span class="k">class</span> <span class="nc">ParamTester</span><span class="p">(</span><span class="n">SemPipeline</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Runs parameter testing for the corpus in question</span>
<span class="sd">    the testing parameters are specified in the self.RunTests function</span>

<span class="sd">    :param c: the number of cores to use in the co-occurrence calculations</span>
<span class="sd">    :type c: int</span>
<span class="sd">    :param jobs: the number of cores to use in the cosine similarity calculations</span>
<span class="sd">    :type jobs: int</span>
<span class="sd">    :param min_count: the minimum occurrence count. Words below this count will not be counted.</span>
<span class="sd">        The purpose here is for memory management. My tests have shown that using all words produces better results.</span>
<span class="sd">    :type min_count: int</span>
<span class="sd">    :param files: the directory path for the .txt files that make up the corpus</span>
<span class="sd">    :type files: str</span>
<span class="sd">    :param stops: the stops words to be ignored in the calculations</span>
<span class="sd">    :type stops: (str)</span>
<span class="sd">    :param min_w: the minimum context window size to use</span>
<span class="sd">    :type min_w: int</span>
<span class="sd">    :param max_w: the maximum context window size to use</span>
<span class="sd">    :type max_w: int</span>
<span class="sd">    :param step: the size of the steps between min_w and max_w</span>
<span class="sd">    :type step: int</span>
<span class="sd">    :param lem_file: the path and filename for the word occurrence dictionary pickle</span>
<span class="sd">    :type lem_file: str</span>
<span class="sd">    :param w_tests: whether to use weighted (&quot;True&quot;) or unweighted (&quot;False&quot;) window types or &quot;both&quot;</span>
<span class="sd">    :type w_tests: str</span>
<span class="sd">    :param l_tests: whether to use word lemmas (&quot;True&quot;) or inflected forms (&quot;False&quot;) or &quot;both&quot;</span>
<span class="sd">    :type l_tests: str</span>
<span class="sd">    :param steps: the steps in the calculation process to perform. Allowed: &#39;all&#39;, &#39;coocs&#39;, &#39;LL&#39;, &#39;PPMI&#39;, &#39;LL_CS&#39; (cosine similarity based on an existing Log-likelihood matrix), or &#39;PPMI_CS&#39;.</span>
<span class="sd">    :type steps: str</span>

<span class="sd">    :ivar c: the number of cores to use in the co-occurrence calculations</span>
<span class="sd">    :type c: int</span>
<span class="sd">    :ivar stops: list of stop words to ignore during the calculations</span>
<span class="sd">    :type stops: (str)</span>
<span class="sd">    :ivar min_count: the minimum number of occurrences for a word to be used in the calculations</span>
<span class="sd">    :type min_count: int</span>
<span class="sd">    :ivar files: the directory path for the .txt files that make up the corpus</span>
<span class="sd">    :type files: str</span>
<span class="sd">    :ivar sim_algo: the similarity algorithm to use in the calculations</span>
<span class="sd">    :type sim_algo: str</span>
<span class="sd">    :ivar ind: the indices for the rows and columns of the matrix (i.e., the words) - filled in self.cooc_counter</span>
<span class="sd">    :type ind: [str]</span>
<span class="sd">    :ivar cols: the length of self.ind - filled in self.cooc_counter</span>
<span class="sd">    :ivar cols: int</span>
<span class="sd">    :ivar coll_df: transformed into numpy.memmap and filled in self.cooc_counter</span>
<span class="sd">    :type coll_df: tuple</span>
<span class="sd">    :ivar LL_df: transformed into numpy.memmap and filled in self.LL</span>
<span class="sd">    :type LL_df: tuple</span>
<span class="sd">    :ivar PPMI_df: transformed into numpy.memmap and filled in self.PPMI</span>
<span class="sd">    :type PPMI_df: tuple</span>
<span class="sd">    :ivar CS_df: transformed into numpy.memmap and filled in self.CS</span>
<span class="sd">    :type CS_df: tuple</span>
<span class="sd">    :ivar stat_df: filled with either self.PPMI_df or self.LL_df in self.CS</span>
<span class="sd">    :type stat_df: tuple</span>
<span class="sd">    :ivar param_dict: filled with the scores for each set of parameters in self.RunTests</span>
<span class="sd">    :type param_dict: dict</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_w</span><span class="p">,</span> <span class="n">max_w</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">min_count</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">files</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">stops</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(),</span> <span class="n">lem_file</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">w_tests</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">l_tests</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Runs parameter testing for the corpus in question</span>
<span class="sd">        the testing parameters are specified in the self.RunTests function</span>

<span class="sd">        :param c: the number of cores to use in the co-occurrence calculations</span>
<span class="sd">        :type c: int</span>
<span class="sd">        :param jobs: the number of cores to use in the cosine similarity calculations</span>
<span class="sd">        :type jobs: int</span>
<span class="sd">        :param min_count: the minimum occurrence count. Words below this count will not be counted.</span>
<span class="sd">            The purpose here is for memory management. My tests have shown that using all words produces better results.</span>
<span class="sd">        :type min_count: int</span>
<span class="sd">        :param files: the directory path for the .txt files that make up the corpus</span>
<span class="sd">        :type files: str</span>
<span class="sd">        :param stops: the stops words to be ignored in the calculations</span>
<span class="sd">        :type stops: (str)</span>
<span class="sd">        :param min_w: the minimum context window size to use</span>
<span class="sd">        :type min_w: int</span>
<span class="sd">        :param max_w: the maximum context window size to use</span>
<span class="sd">        :type max_w: int</span>
<span class="sd">        :param step: the size of the steps between min_w and max_w</span>
<span class="sd">        :type step: int</span>
<span class="sd">        :param lem_file: the path and filename for the word occurrence dictionary pickle</span>
<span class="sd">        :type lem_file: str</span>
<span class="sd">        :param w_tests: whether to use weighted (&quot;True&quot;) or unweighted (&quot;False&quot;) window types or &quot;both&quot;</span>
<span class="sd">        :type w_tests: str</span>
<span class="sd">        :param l_tests: whether to use word lemmas (&quot;True&quot;) or inflected forms (&quot;False&quot;) or &quot;both&quot;</span>
<span class="sd">        :type l_tests: str</span>
<span class="sd">        :param steps: the steps in the calculation process to perform. Allowed: &#39;all&#39;, &#39;coocs&#39;, &#39;LL&#39;, &#39;PPMI&#39;, &#39;LL_CS&#39; (cosine similarity based on an existing Log-likelihood matrix), or &#39;PPMI_CS&#39;.</span>
<span class="sd">        :type steps: str</span>

<span class="sd">        :ivar c: the number of cores to use in the co-occurrence calculations</span>
<span class="sd">        :type c: int</span>
<span class="sd">        :ivar stops: list of stop words to ignore during the calculations</span>
<span class="sd">        :type stops: (str)</span>
<span class="sd">        :ivar min_count: the minimum number of occurrences for a word to be used in the calculations</span>
<span class="sd">        :type min_count: int</span>
<span class="sd">        :ivar files: the directory path for the .txt files that make up the corpus</span>
<span class="sd">        :type files: str</span>
<span class="sd">        :ivar sim_algo: the similarity algorithm to use in the calculations</span>
<span class="sd">        :type sim_algo: str</span>
<span class="sd">        :ivar ind: the indices for the rows and columns of the matrix (i.e., the words) - filled in self.cooc_counter</span>
<span class="sd">        :type ind: [str]</span>
<span class="sd">        :ivar cols: the length of self.ind - filled in self.cooc_counter</span>
<span class="sd">        :ivar cols: int</span>
<span class="sd">        :ivar coll_df: transformed into numpy.memmap and filled in self.cooc_counter</span>
<span class="sd">        :type coll_df: tuple</span>
<span class="sd">        :ivar LL_df: transformed into numpy.memmap and filled in self.LL</span>
<span class="sd">        :type LL_df: tuple</span>
<span class="sd">        :ivar PPMI_df: transformed into numpy.memmap and filled in self.PPMI</span>
<span class="sd">        :type PPMI_df: tuple</span>
<span class="sd">        :ivar CS_df: transformed into numpy.memmap and filled in self.CS</span>
<span class="sd">        :type CS_df: tuple</span>
<span class="sd">        :ivar stat_df: filled with either self.PPMI_df or self.LL_df in self.CS</span>
<span class="sd">        :type stat_df: tuple</span>
<span class="sd">        :ivar param_dict: filled with the scores for each set of parameters in self.RunTests</span>
<span class="sd">        :type param_dict: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">c</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stops</span> <span class="o">=</span> <span class="n">stops</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jobs</span> <span class="o">=</span> <span class="n">jobs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_count</span> <span class="o">=</span> <span class="n">min_count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">orig</span> <span class="o">=</span> <span class="n">files</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sim_algo</span> <span class="o">=</span> <span class="s1">&#39;CS&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_w</span> <span class="o">=</span> <span class="n">min_w</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_w</span> <span class="o">=</span> <span class="n">max_w</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">step</span> <span class="o">=</span> <span class="n">step</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">w_tests</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">w_tests</span> <span class="o">==</span> <span class="s1">&#39;both&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">w_tests</span> <span class="o">=</span> <span class="p">(</span><span class="bp">True</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">w_tests</span> <span class="o">==</span> <span class="s1">&#39;True&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">w_tests</span> <span class="o">=</span> <span class="p">[</span><span class="bp">True</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">w_tests</span> <span class="o">==</span> <span class="s1">&#39;False&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">w_tests</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">w_tests</span> <span class="o">=</span> <span class="n">w_tests</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">l_tests</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">l_tests</span> <span class="o">==</span> <span class="s1">&#39;both&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">l_tests</span> <span class="o">=</span> <span class="p">(</span><span class="bp">True</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">l_tests</span> <span class="o">==</span> <span class="s1">&#39;True&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">l_tests</span> <span class="o">=</span> <span class="p">[</span><span class="bp">True</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">l_tests</span> <span class="o">==</span> <span class="s1">&#39;False&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">l_tests</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">l_tests</span> <span class="o">=</span> <span class="n">l_tests</span>
        <span class="k">if</span> <span class="n">lem_file</span> <span class="o">==</span> <span class="s1">&#39;None&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lem_file</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lem_file</span> <span class="o">=</span> <span class="n">lem_file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">do_coocs</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">do_LL</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">do_PPMI</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">do_LL_CS</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">do_PPMI_CS</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">do_all</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">steps</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">do_coocs</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">do_LL</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">do_PPMI</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">do_LL_CS</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">do_PPMI_CS</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">do_all</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stat_algos</span> <span class="o">=</span> <span class="s1">&#39;Both&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">elif</span> <span class="n">steps</span> <span class="o">==</span> <span class="s1">&#39;coocs&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">do_coocs</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">elif</span> <span class="n">steps</span> <span class="o">==</span> <span class="s1">&#39;LL&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">do_LL</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">elif</span> <span class="n">steps</span> <span class="o">==</span> <span class="s1">&#39;PPMI&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">do_PPMI</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">elif</span> <span class="n">steps</span> <span class="o">==</span> <span class="s1">&#39;LL_CS&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">do_LL_CS</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stat_algos</span> <span class="o">=</span> <span class="s1">&#39;LL&#39;</span>
        <span class="k">elif</span> <span class="n">steps</span> <span class="o">==</span> <span class="s1">&#39;PPMI_CS&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">do_PPMI_CS</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stat_algos</span> <span class="o">=</span> <span class="s1">&#39;PPMI&#39;</span>
        <span class="k">elif</span> <span class="n">steps</span> <span class="o">==</span> <span class="s1">&#39;remove&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="c1"># the following ivars are filled later in the class</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ind</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coll_df</span> <span class="o">=</span> <span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">LL_df</span> <span class="o">=</span> <span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">PPMI_df</span> <span class="o">=</span> <span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">CS_df</span> <span class="o">=</span> <span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stat_df</span> <span class="o">=</span> <span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param_dict</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">cooc_counter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">files</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Counts the number of times each word co-occurs with each other word</span>

<span class="sd">        :return: self.ind - the words that represent the ordered indices of all matrices produced in later calculation</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        :ivar coll_df: the matrix of cooccurrence counts</span>
<span class="sd">        :type coll_df: numpy.memmap</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">()</span>
        <span class="n">min_lems</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lems</span><span class="p">:</span>
            <span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">r&#39;.+?lem=&quot;([^&quot;]*).*&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">r&#39;.+?&gt;([^&lt;]*).*&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="nb">file</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="nb">file</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">words</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">word_extract</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">),</span> <span class="n">pattern</span><span class="p">)</span>
            <span class="n">step</span> <span class="o">=</span> <span class="n">ceil</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">)</span>
            <span class="n">steps</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">):</span>
                <span class="n">steps</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">step</span> <span class="o">*</span> <span class="n">i</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">step</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">))))</span>
            <span class="sd">&#39;&#39;&#39;self.res = group(</span>
<span class="sd">                counter.s(self.weighted, self.w, words, limits) for limits in</span>
<span class="sd">                steps)().get()</span>
<span class="sd">            &#39;&#39;&#39;</span>
            <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">with</span> <span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">limits</span> <span class="ow">in</span> <span class="n">steps</span><span class="p">:</span>
                    <span class="n">results</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weighted</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="n">words</span><span class="p">,</span> <span class="n">limits</span><span class="p">))</span>
                    <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>
            <span class="c1"># since the counter task returns Counter objects, the update method</span>
            <span class="c1"># below adds instead of replacing the values</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">res</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">min_lems</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">counts</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                            <span class="n">counts</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">counts</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ind</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">counts</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ind</span><span class="p">)</span>  <span class="c1"># Need to pickle self.cols for later use</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;{}/{}_{}_{}_index.pickle&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orig</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighted</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lems</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ind</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
        <span class="n">cooc_dest</span> <span class="o">=</span> <span class="s1">&#39;{}/{}_{}_{}_coll_df.dat&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orig</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighted</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lems</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coll_df</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span><span class="n">cooc_dest</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w+&#39;</span><span class="p">,</span>
                                 <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ind</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">counts</span><span class="p">[</span><span class="n">w</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ind</span><span class="p">,</span>
                          <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coll_df</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">values</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">5000</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s1">&#39;{0}</span><span class="si">% d</span><span class="s1">one&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">((</span><span class="n">i</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)))</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">coll_df</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">coll_df</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span><span class="n">cooc_dest</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r+&#39;</span><span class="p">,</span>
                                         <span class="n">shape</span><span class="o">=</span><span class="p">(</span>
                                             <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">))</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">coll_df</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coll_df</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span><span class="n">cooc_dest</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span>
                                 <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">log_like</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">C2</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Guides the process of Log-likelihood calculations for a single row</span>

<span class="sd">        :param row: the index of the row in the table to be calculated</span>
<span class="sd">        :type row: int</span>
<span class="sd">        :param C2: number of co-occurrences for each row of the table (1-D array)</span>
<span class="sd">        :type C2: numpy.ndarray</span>
<span class="sd">        :param P: ratio of co-occurrences per row to total co-occurrences in the table (1-D array)</span>
<span class="sd">        :type P: numpy.ndarray</span>
<span class="sd">        :param N: total number of co-occurrences in the table</span>
<span class="sd">        :type N: float</span>
<span class="sd">        :return: Log-likelihood values for a single row in the table</span>
<span class="sd">        :rtype: numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">C12</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coll_df</span><span class="p">[</span><span class="n">row</span><span class="p">]</span>
        <span class="n">C1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">C12</span><span class="p">)</span>
        <span class="c1"># P1 is the ratio of single co-occurrence values to the total co-occurrences for that row</span>
        <span class="n">P1</span> <span class="o">=</span> <span class="n">C12</span> <span class="o">/</span> <span class="n">C1</span>
        <span class="c1"># P2 is the ratio of total co-occurrences for a word minus the co-occurrences</span>
        <span class="c1"># with the word in question to the total number of co-occurrences in</span>
        <span class="c1"># the table minus the total co-occurrences for the row.</span>
        <span class="n">P2</span> <span class="o">=</span> <span class="p">(</span><span class="n">C2</span> <span class="o">-</span> <span class="n">C12</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="n">C1</span><span class="p">)</span>

        <span class="n">LL1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_space_L</span><span class="p">(</span><span class="n">C12</span><span class="p">,</span> <span class="n">C1</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span>

        <span class="n">LL2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_space_L</span><span class="p">(</span><span class="n">C2</span> <span class="o">-</span> <span class="n">C12</span><span class="p">,</span> <span class="n">N</span> <span class="o">-</span> <span class="n">C1</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span>

        <span class="n">LL3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_L</span><span class="p">(</span><span class="n">C12</span><span class="p">,</span> <span class="n">C1</span><span class="p">,</span> <span class="n">P1</span><span class="p">)</span>

        <span class="c1">#The following finds all inf and -inf values in LL3 by moving calculations into log space.</span>

        <span class="n">LL3_inf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">LL3</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">LL3_inf</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">LL3_inf</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">LL3</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">P1</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span> <span class="o">*</span> <span class="n">C12</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span>
                        <span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">P1</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">C1</span> <span class="o">-</span> <span class="n">C12</span><span class="p">[</span><span class="n">ind</span><span class="p">]))</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="n">LL3</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">LL4</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_space_L</span><span class="p">(</span><span class="n">C2</span> <span class="o">-</span> <span class="n">C12</span><span class="p">,</span> <span class="n">N</span> <span class="o">-</span> <span class="n">C1</span><span class="p">,</span> <span class="n">P2</span><span class="p">)</span>

        <span class="c1">#The following finds all inf and -inf values in LL4 by moving calculations into log space.</span>

        <span class="n">LL4_inf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">LL4</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">LL4_inf</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">LL4_inf</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">LL4</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_L</span><span class="p">((</span><span class="n">C2</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">-</span> <span class="n">C12</span><span class="p">[</span><span class="n">ind</span><span class="p">]),</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="n">C1</span><span class="p">),</span>
                                          <span class="n">P2</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="n">LL4</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">LL1</span> <span class="o">+</span> <span class="n">LL2</span> <span class="o">-</span> <span class="n">LL3</span> <span class="o">-</span> <span class="n">LL4</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">LL</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Guides the Log-likelihood calculations for the whole matrix</span>

<span class="sd">        :return: self.LL_df</span>
<span class="sd">        :rtype: numpy.memmap</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coll_df</span><span class="p">)</span>
        <span class="n">c2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coll_df</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">/</span> <span class="n">n</span>
        <span class="n">LL_df</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span><span class="s1">&#39;{}/{}_{}_{}_LL_memmap.dat&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orig</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighted</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lems</span><span class="p">),</span>
                          <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w+&#39;</span><span class="p">,</span>
                          <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ind</span><span class="p">):</span>
            <span class="n">LL_df</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_like</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">5000</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s1">&#39;{0}</span><span class="si">% d</span><span class="s1">one&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">((</span><span class="n">i</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)))</span>
                <span class="c1"># deleting LL_df periodically clears the memory of rows that have already been calculated</span>
                <span class="k">del</span> <span class="n">LL_df</span>
                <span class="n">LL_df</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span>
                    <span class="s1">&#39;{}/{}_{}_{}_LL_memmap.dat&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orig</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighted</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lems</span><span class="p">),</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r+&#39;</span><span class="p">,</span>
                    <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">))</span>
        <span class="n">LL_df</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">LL_df</span><span class="p">)</span> <span class="o">==</span> <span class="bp">False</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">del</span> <span class="n">LL_df</span>
        <span class="n">LL_df</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span><span class="s1">&#39;{}/{}_{}_{}_LL_memmap.dat&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orig</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighted</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lems</span><span class="p">),</span>
                          <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span>
                          <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">LL_df</span>

    <span class="k">def</span> <span class="nf">PMI_calc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Calculates PPMI values for one table row</span>

<span class="sd">        :param row: index for the word&#39;s row in the table</span>
<span class="sd">        :type row: int</span>
<span class="sd">        :param P2: ratio of co-occurrences per row to total co-occurrences in the table</span>
<span class="sd">        :type P2: numpy.ndarray</span>
<span class="sd">        :param N: total co-occurrences in the table</span>
<span class="sd">        :type N: float</span>
<span class="sd">        :return: PPMI values for a row in the table (1-D array)</span>
<span class="sd">        :rtype: numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">C12</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coll_df</span><span class="p">[</span><span class="n">row</span><span class="p">]</span>
        <span class="n">C1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">C12</span><span class="p">)</span>
        <span class="n">P1</span> <span class="o">=</span> <span class="n">C1</span> <span class="o">/</span> <span class="n">N</span>
        <span class="n">P12</span> <span class="o">=</span> <span class="n">C12</span> <span class="o">/</span> <span class="n">N</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">P12</span><span class="p">,</span> <span class="n">P1</span> <span class="o">*</span> <span class="n">P2</span><span class="p">))</span>
        <span class="n">a</span><span class="p">[</span><span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">a</span>

    <span class="k">def</span> <span class="nf">PPMI</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Guides the PPMI calculation process for the whole table</span>

<span class="sd">        :return: matrix of PPMI values</span>
<span class="sd">        :rtype: numpy.memmap</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coll_df</span><span class="p">)</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coll_df</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span>
        <span class="n">PPMI_df</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span><span class="s1">&#39;{}/{}_{}_{}_PPMI_memmap.dat&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orig</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighted</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lems</span><span class="p">),</span>
                            <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w+&#39;</span><span class="p">,</span>
                            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ind</span><span class="p">):</span>
            <span class="n">PPMI_df</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">PMI_calc</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">5000</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s1">&#39;{0}</span><span class="si">% d</span><span class="s1">one&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">((</span><span class="n">i</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)))</span>
                <span class="k">del</span> <span class="n">PPMI_df</span>
                <span class="n">PPMI_df</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span>
                    <span class="s1">&#39;{}/{}_{}_{}_PPMI_memmap.dat&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orig</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighted</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lems</span><span class="p">),</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r+&#39;</span><span class="p">,</span>
                    <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">))</span>
        <span class="n">PPMI_df</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">PPMI_df</span><span class="p">)</span> <span class="o">==</span> <span class="bp">False</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">del</span> <span class="n">PPMI_df</span>
        <span class="n">PPMI_df</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span><span class="s1">&#39;{}/{}_{}_{}_PPMI_memmap.dat&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orig</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighted</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lems</span><span class="p">),</span>
                            <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span>
                            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">PPMI_df</span>

    <span class="k">def</span> <span class="nf">CS</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">algorithm</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Calculates the cosine similarity of every matrix row with every other row</span>

<span class="sd">        :param algorithm: which algorithm (PPMI or LL) is being tested</span>
<span class="sd">        :type algorithm: str</span>
<span class="sd">        :param e: SVD exponent</span>
<span class="sd">        :type e: float</span>
<span class="sd">        :ivar CS_df: matrix of cosine similarity values</span>
<span class="sd">        :type CS_df: numpy.memmap</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Starting {} calculations for &#39;</span>
              <span class="s1">&#39;w={}, lem={}, weighted={} at {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sim_algo</span><span class="p">,</span>
                                                              <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">),</span>
                                                              <span class="bp">self</span><span class="o">.</span><span class="n">lems</span><span class="p">,</span>
                                                                 <span class="bp">self</span><span class="o">.</span><span class="n">weighted</span><span class="p">,</span>
                                                              <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">.</span><span class="n">isoformat</span><span class="p">()))</span>
        <span class="n">dest_file</span> <span class="o">=</span> <span class="s1">&#39;{}/{}_{}_{}_{}_CS_memmap.dat&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orig</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighted</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lems</span><span class="p">,</span> <span class="n">algorithm</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">algorithm</span> <span class="o">==</span> <span class="s1">&#39;PPMI&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stat_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">PPMI_df</span>
        <span class="k">elif</span> <span class="n">algorithm</span> <span class="o">==</span> <span class="s1">&#39;LL&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stat_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LL_df</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">CS_df</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span><span class="n">dest_file</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w+&#39;</span><span class="p">,</span>
                               <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim_algo</span> <span class="o">==</span> <span class="s1">&#39;cosine&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">CS_df</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">pairwise_distances</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stat_df</span><span class="p">,</span>
                                                   <span class="n">metric</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sim_algo</span><span class="p">,</span>
                                                   <span class="n">n_jobs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">jobs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">CS_df</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">pairwise_distances</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stat_df</span><span class="p">,</span>
                                               <span class="n">metric</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sim_algo</span><span class="p">,</span>
                                               <span class="n">n_jobs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">jobs</span><span class="p">)</span>
        <span class="c1"># self.cs_loop(dest_file)</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">CS_df</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">CS_df</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span><span class="n">dest_file</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span>
                               <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">))</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Finished with {} calculations for &#39;</span>
              <span class="s1">&#39;w={}, lem={}, weighted={} at {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sim_algo</span><span class="p">,</span>
                                                       <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">),</span>
                                                       <span class="bp">self</span><span class="o">.</span><span class="n">lems</span><span class="p">,</span>
                                                       <span class="bp">self</span><span class="o">.</span><span class="n">weighted</span><span class="p">,</span>
                                                       <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">.</span><span class="n">isoformat</span><span class="p">()))</span>

    <span class="k">def</span> <span class="nf">RunTests</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Guides the parameter testing process</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">Chapter_2.LouwNidaCatSim</span> <span class="kn">import</span> <span class="n">CatSimWin</span>

        <span class="n">files</span> <span class="o">=</span> <span class="n">glob</span><span class="p">(</span><span class="s1">&#39;{0}/*.txt&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orig</span><span class="p">))</span>
        <span class="k">for</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_w</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">):</span>
            <span class="k">for</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighted</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_tests</span><span class="p">:</span>
                <span class="k">for</span> <span class="bp">self</span><span class="o">.</span><span class="n">lems</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">l_tests</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;weighted </span><span class="si">%s</span><span class="s1">, lemmata </span><span class="si">%s</span><span class="s1">, w=</span><span class="si">%s</span><span class="s1"> at </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span>
                          <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weighted</span><span class="p">,</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">lems</span><span class="p">,</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">,</span>
                           <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">.</span><span class="n">isoformat</span><span class="p">()))</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_coocs</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">cooc_counter</span><span class="p">(</span><span class="n">files</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ind</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">ind</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_pickle</span><span class="p">(</span><span class="s1">&#39;{}/{}_{}_{}_index.pickle&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orig</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighted</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lems</span><span class="p">))</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ind</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">coll_df</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span><span class="s1">&#39;{}/{}_{}_{}_coll_df.dat&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orig</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighted</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lems</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">))</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_LL</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">LL_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LL</span><span class="p">()</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">coll_df</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_LL_CS</span><span class="p">:</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">LL_df</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">LL_df</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span><span class="s1">&#39;{}/{}_{}_{}_LL_memmap.dat&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orig</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighted</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lems</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">))</span>
                        <span class="n">pipe</span> <span class="o">=</span> <span class="n">CatSimWin</span><span class="p">(</span><span class="s1">&#39;LL&#39;</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">],</span>
                                         <span class="n">lems</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lems</span><span class="p">,</span>
                                         <span class="n">CS_dir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">orig</span><span class="p">,</span>
                                         <span class="n">dest_dir</span><span class="o">=</span><span class="s1">&#39;{}/Win_size_tests/LN&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orig</span><span class="p">),</span>
                                         <span class="n">sim_algo</span><span class="o">=</span><span class="s1">&#39;cosine&#39;</span><span class="p">,</span>
                                         <span class="n">corpus</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orig</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighted</span><span class="p">),</span>
                                         <span class="n">lem_file</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lem_file</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">CS</span><span class="p">(</span><span class="s1">&#39;LL&#39;</span><span class="p">)</span>
                        <span class="n">pipe</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CS_df</span>
                        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">CS_df</span>
                        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">LL_df</span>
                        <span class="n">pipe</span><span class="o">.</span><span class="n">ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ind</span>
                        <span class="n">pipe</span><span class="o">.</span><span class="n">SimCalc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">)</span>
                        <span class="n">pipe</span><span class="o">.</span><span class="n">AveCalc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">)</span>
                        <span class="n">pipe</span><span class="o">.</span><span class="n">WriteFiles</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">param_dict</span><span class="p">[</span><span class="s1">&#39;LL_window={}_lems={}_weighted={}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lems</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighted</span><span class="p">)]</span> <span class="o">=</span> <span class="n">pipe</span><span class="o">.</span><span class="n">ave_no_93</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">]</span>
                        <span class="k">del</span> <span class="n">pipe</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">coll_df</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span><span class="s1">&#39;{}/{}_{}_{}_coll_df.dat&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orig</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighted</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lems</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">))</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_PPMI</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">PPMI_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">PPMI</span><span class="p">()</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">coll_df</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_PPMI_CS</span><span class="p">:</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">PPMI_df</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">PPMI_df</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span><span class="s1">&#39;{}/{}_{}_{}_PPMI_memmap.dat&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orig</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighted</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lems</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">))</span>
                        <span class="n">pipe</span> <span class="o">=</span> <span class="n">CatSimWin</span><span class="p">(</span><span class="s1">&#39;PPMI&#39;</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">],</span>
                                         <span class="n">lems</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lems</span><span class="p">,</span>
                                         <span class="n">CS_dir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">orig</span><span class="p">,</span>
                                         <span class="n">dest_dir</span><span class="o">=</span><span class="s1">&#39;{}/Win_size_tests/LN&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orig</span><span class="p">),</span>
                                         <span class="n">sim_algo</span><span class="o">=</span><span class="s1">&#39;cosine&#39;</span><span class="p">,</span>
                                         <span class="n">corpus</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orig</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighted</span><span class="p">),</span>
                                         <span class="n">lem_file</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lem_file</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">CS</span><span class="p">(</span><span class="s1">&#39;PPMI&#39;</span><span class="p">)</span>
                        <span class="n">pipe</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CS_df</span>
                        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">PPMI_df</span>
                        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">CS_df</span>
                        <span class="n">pipe</span><span class="o">.</span><span class="n">ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ind</span>
                        <span class="n">pipe</span><span class="o">.</span><span class="n">SimCalc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">)</span>
                        <span class="n">pipe</span><span class="o">.</span><span class="n">AveCalc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">)</span>
                        <span class="n">pipe</span><span class="o">.</span><span class="n">WriteFiles</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">param_dict</span><span class="p">[</span><span class="s1">&#39;PPMI_window={}_lems={}_weighted={}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lems</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighted</span><span class="p">)]</span> <span class="o">=</span> <span class="n">pipe</span><span class="o">.</span><span class="n">ave_no_93</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">]</span>
                        <span class="k">del</span> <span class="n">pipe</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">:</span>
                        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;{}/{}_{}_{}_coll_df.dat&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orig</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighted</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lems</span><span class="p">))</span>
                        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;{}/{}_{}_{}_PPMI_memmap.dat&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orig</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighted</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lems</span><span class="p">))</span>
                        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;{}/{}_{}_{}_LL_memmap.dat&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orig</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighted</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lems</span><span class="p">))</span>
                        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;{}/{}_{}_{}_PPMI_CS_memmap.dat&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orig</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighted</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lems</span><span class="p">))</span>
                        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;{}/{}_{}_{}_LL_CS_memmap.dat&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orig</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighted</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lems</span><span class="p">))</span>
                        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;{}/{}_{}_{}_index.pickle&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orig</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighted</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lems</span><span class="p">))</span>
            <span class="k">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_dict</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_LL_CS</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_PPMI_CS</span><span class="p">:</span>
            <span class="n">dest_file</span> <span class="o">=</span> <span class="s1">&#39;{0}/Win_size_tests/{1}_{2}_{3}_weighted={4}_lems={5}_algos={6}.pickle&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">orig</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orig</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_tests</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">l_tests</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stat_algos</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">dest_file</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_dict</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">dest_file</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.pickle&#39;</span><span class="p">,</span> <span class="s1">&#39;.csv&#39;</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;Test Details</span><span class="se">\t</span><span class="s1">Mean Category Score</span><span class="se">\t</span><span class="s1">Category Z-Score&#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span>
                                <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">])):</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">{}</span><span class="se">\t</span><span class="s1">{}</span><span class="se">\t</span><span class="s1">{}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_dict</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                                  <span class="bp">self</span><span class="o">.</span><span class="n">param_dict</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span></div>


<span class="k">def</span> <span class="nf">cmd</span><span class="p">():</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="s1">&#39;Pipeline for automatic extraction of semantic data.&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--win_size&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;The size of the contexts window&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--lemmata&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Whether to use a lemmatized corpus or not&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--weighted&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Whether to use a weighted or unweighted window. &quot;True&quot; == weighted&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--algo&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s1">&#39;LL&#39;</span><span class="p">,</span> <span class="n">choices</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;LL&#39;</span><span class="p">,</span> <span class="s1">&#39;PPMI&#39;</span><span class="p">],</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;The significance algorithm to use&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--files&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;The directory path in which the .txt files for your corpus are located.&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--c&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;The number of cores to use during co-occurrence calculations&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--occ_dict&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;The filepath to the file that contains the dictionary of word occurrences&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--min_count&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;The minimum number of occurrences for words to be considered in the calculations&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--jobs&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;The value for n_jobs in sklearn.metrics.pairwise_distances for cosine similarity calculations&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--stops&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Whether to include stopwords in the calcuations&#39;</span><span class="p">)</span>

    <span class="c1"># Add subparsers for the whole process or for different steps</span>
    <span class="n">subparsers</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">add_subparsers</span><span class="p">(</span><span class="n">dest</span><span class="o">=</span><span class="s1">&#39;subparser_name&#39;</span><span class="p">)</span>
    <span class="n">parser_pipeline</span> <span class="o">=</span> <span class="n">subparsers</span><span class="o">.</span><span class="n">add_parser</span><span class="p">(</span><span class="s1">&#39;SemPipeline&#39;</span><span class="p">)</span>
    <span class="n">parser_pipeline</span><span class="o">.</span><span class="n">set_defaults</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">SemPipeline</span><span class="p">)</span>
    <span class="n">parser_params</span> <span class="o">=</span> <span class="n">subparsers</span><span class="o">.</span><span class="n">add_parser</span><span class="p">(</span><span class="s1">&#39;ParamTester&#39;</span><span class="p">)</span>
    <span class="n">parser_params</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--min_w&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;The minimum context window size to be tested&#39;</span><span class="p">)</span>
    <span class="n">parser_params</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--max_w&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;The maximum context window size to be tested&#39;</span><span class="p">)</span>
    <span class="n">parser_params</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--step&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;The size of the steps to test between min_w and max_w&#39;</span><span class="p">)</span>
    <span class="n">parser_params</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--w_tests&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">choices</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;True&#39;</span><span class="p">,</span> <span class="s1">&#39;False&#39;</span><span class="p">,</span> <span class="s1">&#39;both&#39;</span><span class="p">],</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Whether to test only the weighted window (True), the unweighted (False), or both (both)&#39;</span><span class="p">)</span>
    <span class="n">parser_params</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--l_tests&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">choices</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;True&#39;</span><span class="p">,</span> <span class="s1">&#39;False&#39;</span><span class="p">,</span> <span class="s1">&#39;both&#39;</span><span class="p">],</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Whether to test only the lemmatized text (True), the unlemmatized text (False), or both (both)&#39;</span><span class="p">)</span>
    <span class="n">parser_params</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--steps&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">choices</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;coocs&#39;</span><span class="p">,</span> <span class="s1">&#39;LL&#39;</span><span class="p">,</span> <span class="s1">&#39;PPMI&#39;</span><span class="p">,</span> <span class="s1">&#39;LL_CS&#39;</span><span class="p">,</span> <span class="s1">&#39;PPMI_CS&#39;</span><span class="p">,</span> <span class="s1">&#39;remove&#39;</span><span class="p">],</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;The ParamTester functions to run&#39;</span><span class="p">)</span>
    <span class="n">parser_params</span><span class="o">.</span><span class="n">set_defaults</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">ParamTester</span><span class="p">)</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">subparser_name</span> <span class="o">==</span> <span class="s1">&#39;SemPipeline&#39;</span><span class="p">:</span>
        <span class="n">args</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">**</span><span class="nb">vars</span><span class="p">(</span><span class="n">args</span><span class="p">))</span><span class="o">.</span><span class="n">runPipeline</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">args</span><span class="o">.</span><span class="n">subparser_name</span> <span class="o">==</span> <span class="s1">&#39;ParamTester&#39;</span><span class="p">:</span>
        <span class="n">args</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">**</span><span class="nb">vars</span><span class="p">(</span><span class="n">args</span><span class="p">))</span><span class="o">.</span><span class="n">RunTests</span><span class="p">()</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">cmd</span><span class="p">()</span>

<span class="sd">&#39;&#39;&#39;if __name__ == &#39;__main__&#39;:</span>
<span class="sd">    if sys.argv[1] == &quot;SemPipeLine&quot;:</span>
<span class="sd">        SemPipeline(win_size=int(sys.argv[2]),</span>
<span class="sd">                    lemmata=bool(int(sys.argv[3])),</span>
<span class="sd">                    weighted=bool(int(sys.argv[4])),</span>
<span class="sd">                    algo=sys.argv[5],</span>
<span class="sd">                    files=sys.argv[7],</span>
<span class="sd">                    c=int(sys.argv[8]),</span>
<span class="sd">                    occ_dict=sys.argv[9],</span>
<span class="sd">                    min_count=int(sys.argv[10])).runPipeline()</span>
<span class="sd">    if sys.argv[1] == &quot;ParamTester&quot;:</span>
<span class="sd">        ParamTester(c=int(sys.argv[2]), orig=sys.argv[3],</span>
<span class="sd">                    min_count=int(sys.argv[10])).RunTests(min_w=int(sys.argv[4]),</span>
<span class="sd">                                                          max_w=int(sys.argv[5]),</span>
<span class="sd">                                                          step=int(sys.argv[6]),</span>
<span class="sd">                                                          lem_file=sys.argv[7],</span>
<span class="sd">                                                          w_tests=sys.argv[8],</span>
<span class="sd">                                                          l_tests=sys.argv[9])</span>
<span class="sd">&#39;&#39;&#39;</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2016, Matthew Munson.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.4.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.7</a>
      
    </div>

    

    
  </body>
</html>